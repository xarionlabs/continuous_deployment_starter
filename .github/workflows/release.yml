name: Release

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      deploy_services:
        required: false
        type: string
        default: ''

permissions:
  packages: write
  contents: read

jobs:
  deploy_services:
    name: Deploy Services to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to enable accurate diff

      - name: Determine Changed Files and Affected Services
        id: determine_changes
        run: |
          set -e
          echo "::group::Determining Changes"
          
          # Simplified and more robust git operations
          # Use git merge-base to find the common ancestor instead of complex branch switching
          if git show-ref --verify --quiet refs/remotes/origin/releases; then
            # Find the merge base between current commit and releases branch
            BASE_COMMIT=$(git merge-base HEAD origin/releases 2>/dev/null || echo "")
            
            if [ -n "$BASE_COMMIT" ]; then
              CHANGED_FILES=$(git diff --name-only "$BASE_COMMIT" HEAD 2>/dev/null || echo "")
            else
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only --root HEAD 2>/dev/null || echo "")
            fi
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only --root HEAD 2>/dev/null || echo "")
          fi

          ASSUME_VALUE_CHANGES="false"
          # Heuristic: if the trigger was a schedule or workflow_dispatch (manual), and no files changed, assume value changes.
          if [ "${{ github.event_name }}" == "schedule" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Check if CHANGED_FILES is empty or only whitespace
            if [[ -z "${CHANGED_FILES// }" ]]; then
              echo "::notice::Workflow triggered by schedule or dispatch with no detected file changes. Assuming potential value changes for environment or secrets."
              ASSUME_VALUE_CHANGES="true"
            fi
          fi

          # Ensure the script is executable
          chmod +x .github/workflows/scripts/determine_affected_services.sh

          AFFECTED_SERVICES=$(.github/workflows/scripts/determine_affected_services.sh "$CHANGED_FILES" "$ASSUME_VALUE_CHANGES" 2>/dev/null || echo "")
          echo "affected_services_list=$AFFECTED_SERVICES" >> $GITHUB_OUTPUT
          
          echo "::endgroup::"
        shell: bash

      - name: Notify User of Affected Services
        run: |
          if [ -z "${{ steps.determine_changes.outputs.affected_services_list }}" ]; then
            echo "::notice::No specific services were directly affected by code changes. The release might proceed due to other reasons (e.g., manual trigger, environment changes not tracked by git diff)."
          else
            echo "::notice::Services to be updated: ${{ steps.determine_changes.outputs.affected_services_list }}"
          fi
        shell: bash

      - name: executing remote ssh commands using ssh key
        uses: appleboy/ssh-action@v1.2.0
        timeout-minutes: 30
        continue-on-error: false
        env:
          VARS_JSON: ${{ toJson(vars) }}
          SECRETS_JSON: ${{ toJson(secrets) }}
          AFFECTED_SERVICES: ${{ steps.determine_changes.outputs.affected_services_list }}
          DEPLOY_SERVICES: ${{ inputs.deploy_services }}
          # GITHUB_REPOSITORY_OWNER is available by default in actions
          # RELEASE_TOOL_IMAGE_URL will use latest tag from ghcr.io
          RELEASE_TOOL_IMAGE_URL_FROM_BUILD: ghcr.io/${{ github.repository }}/deployment-manager:latest
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USERNAME }}
          key: ${{ secrets.KEY }}
          envs: VARS_JSON, SECRETS_JSON, AFFECTED_SERVICES, DEPLOY_SERVICES, GITHUB_REPOSITORY_OWNER, GITHUB_REPOSITORY, RELEASE_TOOL_IMAGE_URL_FROM_BUILD
          script: |
            set -e
            set -u
            set -o pipefail
            
            # Function for structured logging
            log_with_timestamp() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
            }
            
            # Function for retry logic
            retry_command() {
              local max_attempts=3
              local delay=5
              local command="$1"
              local attempt=1
              
              while [ $attempt -le $max_attempts ]; do
                if eval "$command" >/dev/null 2>&1; then
                  log_with_timestamp "Command succeeded on attempt $attempt"
                  return 0
                else
                  if [ $attempt -lt $max_attempts ]; then
                    log_with_timestamp "Command failed on attempt $attempt, retrying in $delay seconds..."
                    sleep $delay
                    delay=$((delay * 2))  # Exponential backoff
                  else
                    log_with_timestamp "Command failed on attempt $attempt"
                    # Show error output only on final failure
                    echo "Error details:"
                    eval "$command"
                  fi
                fi
                attempt=$((attempt + 1))
              done
              
              log_with_timestamp "Command failed after $max_attempts attempts"
              return 1
            }
            
            log_with_timestamp "Starting Remote Orchestration"

            REMOTE_USER_HOME=$(eval echo ~$USER)
            # Infer repository name from GITHUB_REPOSITORY, e.g., "owner/repo-name" -> "repo-name"
            # GITHUB_REPOSITORY is passed via `envs` so it's available.
            REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)
            PROJECT_DIR_ON_HOST="$REMOTE_USER_HOME/runtime/${REPO_NAME:-continuous_deployment_starter}"

            log_with_timestamp "Project Directory: $PROJECT_DIR_ON_HOST"
            log_with_timestamp "Release Tool Image: $RELEASE_TOOL_IMAGE_URL_FROM_BUILD"

            if [ ! -d "$PROJECT_DIR_ON_HOST" ]; then
                echo "ERROR: Project directory $PROJECT_DIR_ON_HOST does not exist on remote host."
                exit 1
            fi
            cd "$PROJECT_DIR_ON_HOST"
            retry_command "git pull origin \$(git rev-parse --abbrev-ref HEAD)"
            DEPLOY_SCRIPT_PATH="tools/deployment/scripts/deploy_on_host.sh"

            if [ ! -f "$DEPLOY_SCRIPT_PATH" ]; then
                echo "ERROR: Deploy script $DEPLOY_SCRIPT_PATH not found in $PROJECT_DIR_ON_HOST."
                exit 1
            fi

            chmod +x "$DEPLOY_SCRIPT_PATH" >/dev/null 2>&1

            log_with_timestamp "Executing deployment script..."
            # Pass RELEASE_TOOL_IMAGE_URL_FROM_BUILD to deploy_on_host.sh
            export PYTHON_RELEASE_TOOL_IMAGE="$RELEASE_TOOL_IMAGE_URL_FROM_BUILD"

            # Execute deployment with timeout and error handling
            if timeout 1800 "$DEPLOY_SCRIPT_PATH" "$AFFECTED_SERVICES" "$VARS_JSON" "$SECRETS_JSON" "$DEPLOY_SERVICES" >/dev/null 2>&1; then
              log_with_timestamp "Deployment completed successfully"
            else
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 124 ]; then
                log_with_timestamp "ERROR: Deployment timed out after 30 minutes"
              else
                log_with_timestamp "ERROR: Deployment failed with exit code $EXIT_CODE"
                # Show deployment output only on failure
                echo "Deployment error details:"
                "$DEPLOY_SCRIPT_PATH" "$AFFECTED_SERVICES" "$VARS_JSON" "$SECRETS_JSON" "$DEPLOY_SERVICES" || true
              fi
              exit $EXIT_CODE
            fi

            log_with_timestamp "Remote Orchestration Finished Successfully"