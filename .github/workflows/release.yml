name: Release

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      deploy_services:
        required: false
        type: string
        default: ''

permissions:
  packages: write
  contents: read

jobs:
  deploy_services:
    name: Deploy Services to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to enable accurate diff

      - name: Determine Changed Files and Affected Services
        id: determine_changes
        run: |
          set -e
          echo "::group::Determining Changes"
          
          # Simplified and more robust git operations
          # Use git merge-base to find the common ancestor instead of complex branch switching
          if git show-ref --verify --quiet refs/remotes/origin/releases; then
            # Find the merge base between current commit and releases branch
            BASE_COMMIT=$(git merge-base HEAD origin/releases 2>/dev/null || echo "")
            
            if [ -n "$BASE_COMMIT" ]; then
              echo "Found base commit: $BASE_COMMIT"
              CHANGED_FILES=$(git diff --name-only "$BASE_COMMIT" HEAD)
            else
              echo "No common base found, using previous commit"
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only --root HEAD)
            fi
          else
            echo "Releases branch not found, using previous commit"
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only --root HEAD)
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"

          ASSUME_VALUE_CHANGES="false"
          # Heuristic: if the trigger was a schedule or workflow_dispatch (manual), and no files changed, assume value changes.
          if [ "${{ github.event_name }}" == "schedule" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Check if CHANGED_FILES is empty or only whitespace
            if [[ -z "${CHANGED_FILES// }" ]]; then
              echo "Workflow triggered by schedule or dispatch with no detected file changes. Assuming potential value changes for environment or secrets."
              ASSUME_VALUE_CHANGES="true"
            fi
          fi
          echo "ASSUME_VALUE_CHANGES flag set to: $ASSUME_VALUE_CHANGES"

          # Ensure the script is executable
          chmod +x .github/workflows/scripts/determine_affected_services.sh

          AFFECTED_SERVICES=$(.github/workflows/scripts/determine_affected_services.sh "$CHANGED_FILES" "$ASSUME_VALUE_CHANGES")
          echo "Affected services determined: $AFFECTED_SERVICES"
          echo "affected_services_list=$AFFECTED_SERVICES" >> $GITHUB_OUTPUT
          
          echo "::endgroup::"
        shell: bash

      - name: Notify User of Affected Services
        run: |
          echo "Based on the changes, the following services (and their dependents) will be updated:"
          if [ -z "${{ steps.determine_changes.outputs.affected_services_list }}" ]; then
            echo "No specific services were directly affected by code changes. The release might proceed due to other reasons (e.g., manual trigger, environment changes not tracked by git diff)."
          else
            echo "${{ steps.determine_changes.outputs.affected_services_list }}"
          fi
        shell: bash

      - name: executing remote ssh commands using ssh key
        uses: appleboy/ssh-action@v1.2.0
        timeout-minutes: 30
        continue-on-error: false
        env:
          VARS_JSON: ${{ toJson(vars) }}
          SECRETS_JSON: ${{ toJson(secrets) }}
          AFFECTED_SERVICES: ${{ steps.determine_changes.outputs.affected_services_list }}
          DEPLOY_SERVICES: ${{ inputs.deploy_services }}
          # GITHUB_REPOSITORY_OWNER is available by default in actions
          # RELEASE_TOOL_IMAGE_URL will use latest tag from ghcr.io
          RELEASE_TOOL_IMAGE_URL_FROM_BUILD: ghcr.io/${{ github.repository }}/deployment-manager:latest
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USERNAME }}
          key: ${{ secrets.KEY }}
          envs: VARS_JSON, SECRETS_JSON, AFFECTED_SERVICES, DEPLOY_SERVICES, GITHUB_REPOSITORY_OWNER, GITHUB_REPOSITORY, RELEASE_TOOL_IMAGE_URL_FROM_BUILD
          script: |
            set -e
            set -u
            set -o pipefail
            
            # Function for structured logging
            log_with_timestamp() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
            }
            
            # Function for retry logic
            retry_command() {
              local max_attempts=3
              local delay=5
              local command="$1"
              local attempt=1
              
              while [ $attempt -le $max_attempts ]; do
                log_with_timestamp "Attempt $attempt of $max_attempts: $command"
                if eval "$command"; then
                  log_with_timestamp "Command succeeded on attempt $attempt"
                  return 0
                else
                  log_with_timestamp "Command failed on attempt $attempt"
                  if [ $attempt -lt $max_attempts ]; then
                    log_with_timestamp "Waiting $delay seconds before retry..."
                    sleep $delay
                    delay=$((delay * 2))  # Exponential backoff
                  fi
                fi
                attempt=$((attempt + 1))
              done
              
              log_with_timestamp "Command failed after $max_attempts attempts"
              return 1
            }
            
            log_with_timestamp "Starting Remote Orchestration"

            REMOTE_USER_HOME=$(eval echo ~$USER)
            # Infer repository name from GITHUB_REPOSITORY, e.g., "owner/repo-name" -> "repo-name"
            # GITHUB_REPOSITORY is passed via `envs` so it's available.
            REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)
            PROJECT_DIR_ON_HOST="$REMOTE_USER_HOME/runtime/${REPO_NAME:-continuous_deployment_starter}"

            echo "Project Directory on Host: $PROJECT_DIR_ON_HOST"
            echo "Release Tool Image URL from build: $RELEASE_TOOL_IMAGE_URL_FROM_BUILD" # Use this in deploy_on_host.sh

            if [ ! -d "$PROJECT_DIR_ON_HOST" ]; then
                echo "ERROR: Project directory $PROJECT_DIR_ON_HOST does not exist on remote host."
                exit 1
            fi
            cd "$PROJECT_DIR_ON_HOST"
            retry_command "git pull origin \$(git rev-parse --abbrev-ref HEAD)"
            DEPLOY_SCRIPT_PATH="tools/deployment/scripts/deploy_on_host.sh"

            if [ ! -f "$DEPLOY_SCRIPT_PATH" ]; then
                echo "ERROR: Deploy script $DEPLOY_SCRIPT_PATH not found in $PROJECT_DIR_ON_HOST."
                exit 1
            fi

            echo "Making $DEPLOY_SCRIPT_PATH executable..."
            chmod +x "$DEPLOY_SCRIPT_PATH"

            log_with_timestamp "Executing $DEPLOY_SCRIPT_PATH..."
            # Pass RELEASE_TOOL_IMAGE_URL_FROM_BUILD to deploy_on_host.sh
            export PYTHON_RELEASE_TOOL_IMAGE="$RELEASE_TOOL_IMAGE_URL_FROM_BUILD"

            # Execute deployment with timeout and error handling
            if timeout 1800 "$DEPLOY_SCRIPT_PATH" "$AFFECTED_SERVICES" "$VARS_JSON" "$SECRETS_JSON" "$DEPLOY_SERVICES"; then
              log_with_timestamp "Deployment completed successfully"
            else
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 124 ]; then
                log_with_timestamp "ERROR: Deployment timed out after 30 minutes"
              else
                log_with_timestamp "ERROR: Deployment failed with exit code $EXIT_CODE"
              fi
              exit $EXIT_CODE
            fi

            log_with_timestamp "Remote Orchestration Finished Successfully"