name: Release

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to enable accurate diff

      - name: Determine Changed Files and Affected Services
        id: determine_changes
        run: |
          # Ensure we are on the releases branch or the correct base for diffing
          # This assumes the workflow is triggered on the 'releases' branch or a branch that merges into it.
          # If triggered on a different event/branch, this logic might need adjustment.
          git checkout releases
          git pull origin releases # Ensure local 'releases' is up-to-date with remote for diffing against previous state

          # Get the previous commit on the releases branch.
          # If this is the very first commit, git diff HEAD^ will fail.
          # A more robust way would be to diff against a specific tag of the last successful release.
          # For now, we use HEAD^, which works if there's at least one prior commit.
          PREVIOUS_COMMIT=$(git rev-parse HEAD^) # TODO: Handle case where HEAD^ doesn't exist (e.g. first commit on branch)
          echo "Previous commit (for diff): $PREVIOUS_COMMIT"

          # If PREVIOUS_COMMIT is empty (e.g. first commit in repo/branch), diff against an empty tree.
          # This will list all files as changed.
          if [ -z "$PREVIOUS_COMMIT" ]; then
            echo "No previous commit found (likely first commit on branch), diffing against empty tree (4b825dc642cb6eb9a060e54bf8d69288fbee4904)."
            # 4b825dc642cb6eb9a060e54bf8d69288fbee4904 is the magic number for an empty tree in Git
            CHANGED_FILES=$(git diff --name-only 4b825dc642cb6eb9a060e54bf8d69288fbee4904 HEAD)
          else
            CHANGED_FILES=$(git diff --name-only $PREVIOUS_COMMIT HEAD)
          fi

          echo "Changed files since $PREVIOUS_COMMIT:"
          echo "$CHANGED_FILES"

          ASSUME_VALUE_CHANGES="false"
          # Heuristic: if the trigger was a schedule or workflow_dispatch (manual), and no files changed, assume value changes.
          if [ "${{ github.event_name }}" == "schedule" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Check if CHANGED_FILES is empty or only whitespace
            if [[ -z "${CHANGED_FILES// }" ]]; then
              echo "Workflow triggered by schedule or dispatch with no detected file changes. Assuming potential value changes for environment or secrets."
              ASSUME_VALUE_CHANGES="true"
            fi
          fi
          echo "ASSUME_VALUE_CHANGES flag set to: $ASSUME_VALUE_CHANGES"

          # Ensure the script is executable
          chmod +x .github/workflows/scripts/determine_affected_services.sh

          AFFECTED_SERVICES=$(.github/workflows/scripts/determine_affected_services.sh "$CHANGED_FILES" "$ASSUME_VALUE_CHANGES")
          echo "Affected services determined: $AFFECTED_SERVICES"
          echo "affected_services_list=$AFFECTED_SERVICES" >> $GITHUB_OUTPUT
        shell: bash

      - name: Notify User of Affected Services
        run: |
          echo "Based on the changes, the following services (and their dependents) will be updated:"
          if [ -z "${{ steps.determine_changes.outputs.affected_services_list }}" ]; then
            echo "No specific services were directly affected by code changes. The release might proceed due to other reasons (e.g., manual trigger, environment changes not tracked by git diff)."
          else
            echo "${{ steps.determine_changes.outputs.affected_services_list }}"
          fi
        shell: bash

      - name: executing remote ssh commands using ssh key
        uses: appleboy/ssh-action@v1.2.0
        env:
          VARS_JSON: ${{ toJson(vars) }}
          SECRETS_JSON: ${{ toJson(secrets) }}
          AFFECTED_SERVICES: ${{ steps.determine_changes.outputs.affected_services_list }}
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USERNAME }}
          key: ${{ secrets.KEY }}
          envs: VARS_JSON, SECRETS_JSON, AFFECTED_SERVICES
          script: |
            set -e
            echo "--- Starting Remote Deployment Script ---"

            # Define user and project paths (ensure these are correct for your remote setup)
            REMOTE_USER_HOME=$(eval echo ~$USER) # Gets current user's home dir
            PROJECT_DIR="$REMOTE_USER_HOME/runtime/continuous_deployment_starter" # Main project directory
            SERVICES_DEF_DIR="$PROJECT_DIR/services" # Service definitions
            SCRIPTS_DIR="$PROJECT_DIR/.github/workflows/scripts" # Bash utility scripts
            SYSTEMD_USER_UNITS_DIR="$REMOTE_USER_HOME/.config/containers/systemd" # Quadlet units
            PODMAN_SOCKET="/run/user/$(id -u)/podman/podman.sock"
            SYSTEMD_USER_BUS_SOCKET="/run/user/$(id -u)/bus" # Often needed for systemctl --user

            # Release tool image - replace with your actual image path
            RELEASE_TOOL_IMAGE="ghcr.io/${{ github.repository_owner }}/continuous_deployment_starter/release-tool:latest"
            # Fallback for local testing if github.repository_owner is not set or you want to override
            # RELEASE_TOOL_IMAGE_OWNER=${GITHUB_REPOSITORY_OWNER:-your_docker_hub_user_or_ghcr_org}
            # RELEASE_TOOL_IMAGE="ghcr.io/$RELEASE_TOOL_IMAGE_OWNER/continuous_deployment_starter/release-tool:latest"


            echo "Project Directory: $PROJECT_DIR"
            echo "Services Definitions: $SERVICES_DEF_DIR"
            echo "Systemd User Units: $SYSTEMD_USER_UNITS_DIR"
            echo "Release Tool Image: $RELEASE_TOOL_IMAGE"
            echo "Affected services on remote: $AFFECTED_SERVICES"

            # Ensure critical directories exist
            mkdir -p "$PROJECT_DIR"
            mkdir -p "$SYSTEMD_USER_UNITS_DIR"
            # The appleboy/ssh-action should sync the repo content to $PROJECT_DIR if `sync_files` is used
            # or if the remote host already has the repo checked out at $PROJECT_DIR.
            # For this script, we assume $PROJECT_DIR contains the latest code (including $SCRIPTS_DIR and $SERVICES_DEF_DIR).
            cd "$PROJECT_DIR"

            echo "Pulling latest release tool image..."
            if ! podman pull "$RELEASE_TOOL_IMAGE"; then
                echo "‚ùå Failed to pull release tool image: $RELEASE_TOOL_IMAGE. Deployment aborted."
                exit 1
            fi

            # 1. Refresh Podman Secrets (Bash script on host)
            echo "--- Refreshing Podman Secrets ---"
            if [ -f "$SCRIPTS_DIR/refresh_podman_secrets.sh" ]; then
              "$SCRIPTS_DIR/refresh_podman_secrets.sh" "$SECRETS_JSON"
            else
              echo "Warning: refresh_podman_secrets.sh not found at $SCRIPTS_DIR"
            fi

            # 2. Create .env file (Bash script on host)
            echo "--- Creating Environment Variables File ---"
            if [ -f "$SCRIPTS_DIR/create_env_variables.sh" ]; then
              # This script should ideally take VARS_JSON as input if it's complex
              # For now, assuming it knows how to get vars or $VARS_JSON is available to it
              # If it needs VARS_JSON, it should be passed: "$SCRIPTS_DIR/create_env_variables.sh" "$VARS_JSON"
              "$SCRIPTS_DIR/create_env_variables.sh" # Assuming it generates .env in current dir ($PROJECT_DIR)
            else
              echo "Warning: create_env_variables.sh not found at $SCRIPTS_DIR"
            fi

            echo "--- Sourcing .env files ---"
            set -o allexport
            if [ -f ".env" ]; then source .env; else echo "Warning: $PROJECT_DIR/.env not found."; fi
            if [ -f "services/version.env" ]; then source services/version.env; else echo "Warning: $PROJECT_DIR/services/version.env not found."; fi
            set +o allexport

            # 3. Check Service Envs (Bash script on host, if still needed)
            echo "--- Checking Service Environment Variables ---"
            if [ -f "$SCRIPTS_DIR/check-service-envs.sh" ]; then
              "$SCRIPTS_DIR/check-service-envs.sh"
            else
              echo "Warning: check-service-envs.sh not found at $SCRIPTS_DIR"
            fi

            # 4. Generate Quadlet Units (Python tool in Docker)
            echo "--- Generating Quadlet Units ---"
            # Ensure VARS_JSON is properly escaped for CLI argument if it contains spaces or special chars.
            # Using single quotes around "$VARS_JSON" is generally safer.
            podman run --rm \
              -v "$SERVICES_DEF_DIR:/app/services:ro" \
              -v "$SYSTEMD_USER_UNITS_DIR:/app/output_units:rw" \
              "$RELEASE_TOOL_IMAGE" generate-units \
                --affected-services "$AFFECTED_SERVICES" \
                --services-dir "/app/services" \
                --output-dir "/app/output_units" \
                --meta-target "all-containers.target" \
                --vars-json "$VARS_JSON"

            # 5. Quadlet Dry Run (on host)
            echo "--- Running Quadlet Dry Run ---"
            if [ -x "/usr/libexec/podman/quadlet" ]; then
              /usr/libexec/podman/quadlet --dryrun --user --no-header "$SYSTEMD_USER_UNITS_DIR"
            else
              echo "Warning: /usr/libexec/podman/quadlet not found. Skipping dry run."
            fi

            # 6. Generate Meta Services (e.g., all-containers.target) (Bash script on host)
            echo "--- Generating Meta Services ---"
            if [ -f "$SCRIPTS_DIR/generate_meta_services.sh" ]; then
              "$SCRIPTS_DIR/generate_meta_services.sh"
            else
              echo "Warning: generate_meta_services.sh not found at $SCRIPTS_DIR"
            fi

            # 7. Pull Latest Images (Python tool in Docker)
            echo "--- Pulling Container Images ---"
            podman run --rm \
              -v "$PODMAN_SOCKET:/var/run/podman/podman.sock:Z" \
              -v "$SYSTEMD_USER_UNITS_DIR:/app/units:ro" \
              "$RELEASE_TOOL_IMAGE" pull-images \
                --affected-services "$AFFECTED_SERVICES" \
                --units-dir "/app/units"

            # 8. Restart Services (Python tool in Docker)
            echo "--- Restarting Services ---"
            podman run --rm \
              -v "$PODMAN_SOCKET:/var/run/podman/podman.sock:Z" \
              -v "$SYSTEMD_USER_BUS_SOCKET:/run/systemd/user/bus:Z" \
              # Potentially other mounts if systemctl needs more context, e.g. /etc/machine-id:ro
              "$RELEASE_TOOL_IMAGE" manage-services restart \
                --affected-services "$AFFECTED_SERVICES"
                # units_dir is not strictly needed by manage-services restart if systemd already loaded them

            # 9. Podman Auto-Update (on host)
            echo "--- Triggering Podman Auto-Update ---"
            podman auto-update || echo "Podman auto-update command failed or found no updates, continuing..."

            echo "--- Remote Deployment Script Finished ---"