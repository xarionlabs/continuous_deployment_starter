name: Release

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to enable accurate diff

      - name: Determine Changed Files and Affected Services
        id: determine_changes
        run: |
          # Ensure we are on the releases branch or the correct base for diffing
          # This assumes the workflow is triggered on the 'releases' branch or a branch that merges into it.
          # If triggered on a different event/branch, this logic might need adjustment.
          git checkout releases
          git pull origin releases # Ensure local 'releases' is up-to-date with remote for diffing against previous state

          # Get the previous commit on the releases branch.
          # If this is the very first commit, git diff HEAD^ will fail.
          # A more robust way would be to diff against a specific tag of the last successful release.
          # For now, we use HEAD^, which works if there's at least one prior commit.
          PREVIOUS_COMMIT=$(git rev-parse HEAD^) # TODO: Handle case where HEAD^ doesn't exist (e.g. first commit on branch)
          echo "Previous commit (for diff): $PREVIOUS_COMMIT"

          # If PREVIOUS_COMMIT is empty (e.g. first commit in repo/branch), diff against an empty tree.
          # This will list all files as changed.
          if [ -z "$PREVIOUS_COMMIT" ]; then
            echo "No previous commit found (likely first commit on branch), diffing against empty tree (4b825dc642cb6eb9a060e54bf8d69288fbee4904)."
            # 4b825dc642cb6eb9a060e54bf8d69288fbee4904 is the magic number for an empty tree in Git
            CHANGED_FILES=$(git diff --name-only 4b825dc642cb6eb9a060e54bf8d69288fbee4904 HEAD)
          else
            CHANGED_FILES=$(git diff --name-only $PREVIOUS_COMMIT HEAD)
          fi

          echo "Changed files since $PREVIOUS_COMMIT:"
          echo "$CHANGED_FILES"

          ASSUME_VALUE_CHANGES="false"
          # Heuristic: if the trigger was a schedule or workflow_dispatch (manual), and no files changed, assume value changes.
          if [ "${{ github.event_name }}" == "schedule" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Check if CHANGED_FILES is empty or only whitespace
            if [[ -z "${CHANGED_FILES// }" ]]; then
              echo "Workflow triggered by schedule or dispatch with no detected file changes. Assuming potential value changes for environment or secrets."
              ASSUME_VALUE_CHANGES="true"
            fi
          fi
          echo "ASSUME_VALUE_CHANGES flag set to: $ASSUME_VALUE_CHANGES"

          # Ensure the script is executable
          chmod +x .github/workflows/scripts/determine_affected_services.sh

          AFFECTED_SERVICES=$(.github/workflows/scripts/determine_affected_services.sh "$CHANGED_FILES" "$ASSUME_VALUE_CHANGES")
          echo "Affected services determined: $AFFECTED_SERVICES"
          echo "affected_services_list=$AFFECTED_SERVICES" >> $GITHUB_OUTPUT
        shell: bash

      - name: Notify User of Affected Services
        run: |
          echo "Based on the changes, the following services (and their dependents) will be updated:"
          if [ -z "${{ steps.determine_changes.outputs.affected_services_list }}" ]; then
            echo "No specific services were directly affected by code changes. The release might proceed due to other reasons (e.g., manual trigger, environment changes not tracked by git diff)."
          else
            echo "${{ steps.determine_changes.outputs.affected_services_list }}"
          fi
        shell: bash

      - name: executing remote ssh commands using ssh key
        uses: appleboy/ssh-action@v1.2.0
        env:
          VARS_JSON: ${{ toJson(vars) }}
          SECRETS_JSON: ${{ toJson(secrets) }}
          AFFECTED_SERVICES: ${{ steps.determine_changes.outputs.affected_services_list }}
        with:
          host: ${{ vars.HOST }}
          username: ${{ vars.USERNAME }}
          key: ${{ secrets.KEY }}
          envs: VARS_JSON, SECRETS_JSON, AFFECTED_SERVICES, GITHUB_REPOSITORY_OWNER # Pass GITHUB_REPOSITORY_OWNER for image name
          script: |
            set -e
            echo "--- Starting Remote Orchestration ---"

            # Define project path (ensure this is correct for your remote setup)
            # appleboy/ssh-action typically syncs to a directory based on the repo name in the user's home.
            # Or, if your server has a fixed checkout path, use that.
            # For this example, let's assume it's in ~/runtime/<repo_name>
            REMOTE_USER_HOME=$(eval echo ~$USER)
            # Infer repository name from GITHUB_REPOSITORY, e.g., "owner/repo-name" -> "repo-name"
            REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)
            PROJECT_DIR_ON_HOST="$REMOTE_USER_HOME/runtime/${REPO_NAME:-continuous_deployment_starter}" # Default if GITHUB_REPOSITORY is not set

            echo "Project Directory on Host: $PROJECT_DIR_ON_HOST"
            echo "GitHub Repository Owner (for image path): $GITHUB_REPOSITORY_OWNER"

            # Navigate to the project directory.
            # The content should have been synced by the ssh-action (default behavior) or a previous step.
            if [ ! -d "$PROJECT_DIR_ON_HOST" ]; then
                echo "ERROR: Project directory $PROJECT_DIR_ON_HOST does not exist on remote host."
                echo "Ensure the repository content is checked out or synced to this location."
                exit 1
            fi
            cd "$PROJECT_DIR_ON_HOST"

            DEPLOY_SCRIPT_PATH=".github/workflows/scripts/deploy_on_host.sh"

            if [ ! -f "$DEPLOY_SCRIPT_PATH" ]; then
                echo "ERROR: Deploy script $DEPLOY_SCRIPT_PATH not found in $PROJECT_DIR_ON_HOST."
                exit 1
            fi

            echo "Making deploy_on_host.sh executable..."
            chmod +x "$DEPLOY_SCRIPT_PATH"

            echo "Executing deploy_on_host.sh..."
            # Pass GITHUB_REPOSITORY_OWNER explicitly if deploy_on_host.sh uses it for image path construction
            # This is already available as an env var if passed via `envs:` to ssh-action.
            # The deploy_on_host.sh script can then use it, e.g. RELEASE_TOOL_IMAGE_OWNER="${GITHUB_REPOSITORY_OWNER}"

            # Important: Ensure that VARS_JSON and SECRETS_JSON are passed in a way that handles
            # potential spaces and special characters within the JSON strings when used as script arguments.
            # Quoting them is essential.
            "$DEPLOY_SCRIPT_PATH" "$AFFECTED_SERVICES" "$VARS_JSON" "$SECRETS_JSON"

            echo "--- Remote Orchestration Finished ---"