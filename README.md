# Readme

## Server setup
 - Run as root
 - Install podman `apt-get -y install podman`
 - create group thempods `groupadd thempods`
 - add live `useradd -m -g thempods live`
 - add staging `useradd -m -g thempods staging`
 - add global_services `useradd -m -g thempods global_services`
 - check uid ranges for these users and groups to make sure that they are not overlapping. `grep live /etc/subuid /etc/subgid` `grep staging /etc/subuid /etc/subgid`. If they are overlapping, use https://github.com/containers/podman/blob/main/docs/tutorials/rootless_tutorial.md#etcsubuid-and-etcsubgid-configuration
 - sudo chsh -s /bin/bash global_services
 - sudo chsh -s /bin/bash live
 - sudo chsh -s /bin/bash staging


## Example folder structure

- .github
  - workflows
    - build.yml
    - test.yml
    - deploy.yml
- applications 
  - chatbot
    - src
    - dockerfile
  - docker-compose.yaml # defines all applications for local development
- services
  - applications
    - docker-compose.yaml # implementing all applications that we want to deploy
    - example.env # gitignored, per environment we implement the .env file
  - tradingbot, webapp, etc.
  - postgres
    - docker-compose.yaml
    - example.env # gitignored, per environment we implement the .env file
    - config.conf
  - mongodb, redis, litellm, chromadb, nginx, etc.
  - version.env
- workers # to be figured out
- README
- .gitignore
- etc

### Assumptions
* Docker containers contain the codebase under /app. (in the dockerfile, always set WORKDIR /app)
* In /app, there is the `entrypoint.sh` and `test.sh`. 
  * `entrypoint.sh`: shell script to run the application
  * `test.sh`: shell script to run the tests. (should contain something like `pytest`, `mvn clean test`, `npm test`, etc.)


### Todo
- How to handle environment specific configurations for networking. 
- install a log aggregator such as fluentbit.io

## Continuous Deployment Process
### In short
  - ssh to build server and trigger build
    - run tests
    - create docker images
    - publish docker images
  - ssh to staging server 
    - download the artifact
    - deploy the version
    - run acceptance tests
    - if it fails, notify user and stop the process - your staging is down, you need to fix it now! 
  - ssh to live server
    - download the artifact
    - deploy the version
    - run acceptance tests 

### Details
- **Tagging**: We use the build time for tagging the build. 
  - This tag is used as a github tag and a version for the docker images generated by the process.
- **Release Branch**: We have a branch called *releases*. This branch has extra commits that append the latest version in `services/applications/version.env`. The bottom line of this file indicates the APP_VERSION env variable. This env variable is going to be used by all the services that are developed by us. When we pull the latest `releases` branch, we should get the latest deployed (or deployable) version with the version at the bottom of the `services/version.env` file. 
- **Applications**: all applications needto be defined as a deployable docker-compose item under `services/applications/docker-compose.yaml`




